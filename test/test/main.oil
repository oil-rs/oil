use std/io as io
use std/option for Option
use std/convert as conv
use std/unreachable for unreachable

/// Represents linked list node
type Node(value: dyn) {
    /// Next node
    let next: Option = Option.None()
    /// Value
    let value: dyn = value
    /// Gets last node
    pub fn last(): Node {
        match self.next {
            Option.None() -> {
                return self
            }
            Option.Some { element } -> {
                return element.last()
            }
            _ -> {
                return unreachable()
            }
        }
    }
    /// Inserts new Node
    pub fn insert(value: dyn) {
        self.next = Option.Some(Node(value))
    }
    /// Deletes node
    pub fn delete(value: dyn): Option {
        if self.value == value {
            return self.next
        }
        match self.next {
            Option.Some { element } -> {
                if element.value == value {
                    self.next = element.next
                } else {
                    self.next = element.delete(value)
                }
            }
            _ -> {}
        }
        return Option.Some(self)
    }
    /// To string
    pub fn to_string(): string {
        let string = conv.string(self.value)
        match self.next {
            Option.None() -> {
                return string
            }
            Option.Some { element } -> {
                return string <> ", " <> conv.string(element.to_string()) // todo
            }
            _ -> {
                return unreachable()
            }
        }
    }
}

/// Represents list type
pub type List {
    /// Head
    let head: Option = Option.None()

    /// Appends element
    pub fn push(value: dyn) {
        match self.head {
            Option.None() -> {
                self.head = Option.Some(Node(value))
            }
            Option.Some { element } -> {
                element.last().insert(value)
            }
            _ -> {
                return unreachable()
            }
        }
    }

    /// Deletes element
    pub fn delete(value: dyn) {
        match self.head {
            Option.None() -> {
                done
            }
            Option.Some { element } -> {
                self.head = element.delete(value)
            }
            _ -> {
                return unreachable()
            }
        }
    }

    /// To string
    pub fn to_string(): string {
        match self.head {
            Option.None() -> {
                return "[]"
            }
            Option.Some { element } -> {
                return "[" <> conv.string(element.to_string()) <> "]"
            }
            _ -> {
                return unreachable()
            }
        }
    }
}


fn a(): int {
    while true {
        if 3 == 3 {
             return 1
        } elif 3 > 4 {
             break
        }
    }
    return 3
}

fn main() {
    let list = List()
    list.push(1)
    list.push("hello")
    list.push(true)
    list.push(false)
    io.println(list.to_string())
    list.delete("hello")
    io.println(list.to_string())
    list.delete(false)
    io.println(list.to_string())
    list.delete(1)
    io.println(list.to_string())
}
